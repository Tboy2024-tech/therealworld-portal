import{jsx as _jsx,Fragment as _Fragment}from"react/jsx-runtime";import{useRef,useEffect}from"react";function MatrixEffect(){const canvasRef=useRef(null);useEffect(()=>{const canvas=canvasRef.current;const ctx=canvas.getContext("2d");// Function to update canvas size
const updateCanvasSize=()=>{canvas.width=window.innerWidth;canvas.height=window.innerHeight;};// Update canvas size on mount and add resize event listener
updateCanvasSize();window.addEventListener("resize",updateCanvasSize);let letters="ABCDEFGHIJKLMNOPQRSTUVXYZABCDEFGHIJKLMNOPQRSTUVXYZABCDEFGHIJKLMNOPQRSTUVXYZABCDEFGHIJKLMNOPQRSTUVXYZABCDEFGHIJKLMNOPQRSTUVXYZABCDEFGHIJKLMNOPQRSTUVXYZ";letters=letters.split("");const fontSize=10// You can make this dynamic based on screen size if necessary
;const columns=canvas.width/fontSize;const drops=Array.from({length:columns}).fill(1);function draw(){ctx.fillStyle="rgba(0, 0, 0, .1)";ctx.fillRect(0,0,canvas.width,canvas.height);for(let i=0;i<drops.length;i++){const text=letters[Math.floor(Math.random()*letters.length)];ctx.fillStyle="#0f0";ctx.fillText(text,i*fontSize,drops[i]*fontSize);drops[i]++;if(drops[i]*fontSize>canvas.height&&Math.random()>.95){drops[i]=0;}}}const intervalId=setInterval(draw,30);// Cleanup: Remove event listener and clear interval on unmount
return()=>{clearInterval(intervalId);window.removeEventListener("resize",updateCanvasSize);};},[]);// Inline styles
const canvasStyle={display:"block",width:"100vw",height:"100vh"};const bodyStyle={margin:0,padding:0,background:"#000"};return /*#__PURE__*/_jsx(_Fragment,{children:/*#__PURE__*/_jsx("div",{style:bodyStyle,children:/*#__PURE__*/_jsx("canvas",{ref:canvasRef,style:canvasStyle})})});}export default MatrixEffect;
export const __FramerMetadata__ = {"exports":{"default":{"type":"reactComponent","name":"MatrixEffect","slots":[],"annotations":{"framerContractVersion":"1"}},"__FramerMetadata__":{"type":"variable"}}}
//# sourceMappingURL=./Matrixeffect.map